---
name: terraform-stacks
description: Comprehensive guide for working with HashiCorp Terraform Stacks. Use when creating, modifying, or validating Terraform Stack configurations (.tfcomponent.hcl, .tfdeploy.hcl files), working with stack components and deployments from local modules, public registry, or private registry sources, managing multi-region or multi-environment infrastructure, or troubleshooting Terraform Stacks syntax and structure.
---

# Terraform Stacks

## Documentation References

When you need detailed information about specific Stacks features, use the fetch_webpage tool to retrieve the latest documentation:

- **Component Blocks**: https://developer.hashicorp.com/terraform/language/block/stack/tfcomponent
  - Component block syntax and arguments
  - Meta-arguments: for_each, depends_on, lifecycle
  - Provider assignments and version constraints
  
- **Deployment Blocks**: https://developer.hashicorp.com/terraform/language/block/stack/tfdeploy
  - Deployment, deployment_group, deployment_auto_approve syntax
  - Store blocks for variable sets
  - Identity tokens for OIDC
  - Publish/upstream outputs for linked Stacks
  
- **Meta-Arguments**: https://developer.hashicorp.com/terraform/language/meta-arguments
  - for_each usage patterns in Stacks
  - depends_on for explicit dependencies
  - lifecycle for managing resource behavior

Use these references when users ask about specific syntax, available arguments, or advanced patterns not covered in this guide.

# Terraform Stacks Overview

Terraform Stacks simplify infrastructure provisioning and management at scale by providing a configuration layer above traditional Terraform modules. Stacks enable declarative orchestration of multiple components across environments, regions, and cloud accounts.

## Core Concepts

**Stack**: A complete unit of infrastructure composed of components and deployments that can be managed together.

**Component**: An abstraction around a Terraform module that defines infrastructure pieces. Each component specifies a source module, inputs, and providers.

**Deployment**: An instance of all components in a stack with specific input values. Use deployments for different environments (dev/staging/prod), regions, or cloud accounts.

**Stack Language**: A separate HCL-based language (not regular Terraform HCL) with distinct blocks and file extensions.

## File Structure

Terraform Stacks use specific file extensions:

- **Component configuration**: `.tfcomponent.hcl` (newer, recommended)
- **Deployment configuration**: `.tfdeploy.hcl`
- **Provider lock file**: `.terraform.lock.hcl` (generated by CLI)

All configuration files must be at the root level of the Stack repository. HCP Terraform processes all files in dependency order.

### Recommended File Organization

```
my-stack/
├── variables.tfcomponent.hcl        # Variable declarations
├── providers.tfcomponent.hcl        # Provider configurations
├── components.tfcomponent.hcl       # Component definitions
├── outputs.tfcomponent.hcl          # Stack outputs
├── deployments.tfdeploy.hcl     # Deployment definitions
├── .terraform.lock.hcl          # Provider lock file (generated)
└── modules/                     # Local modules
    ├── vpc/
    └── compute/
```

## Component Configuration (.tfcomponent.hcl)

### Variable Block

Declare input variables for the Stack configuration. Variables must define a `type` field.

**Supported Variable Properties:**
- `type` - Required: Variable type (string, number, bool, list, map, set, object, tuple)
- `description` - Optional: Human-readable description
- `default` - Optional: Default value if not provided
- `sensitive` - Optional: Mark as sensitive (hidden in logs)
- `ephemeral` - Optional: Don't persist to state file (for tokens/secrets)
- `nullable` - Optional: Allow null values

**Not Supported:**
- `validation` blocks - Validation not supported in Stack variables (validate in component modules instead)
- `nullable` attribute - Not supported in Terraform Stacks v1.13.5+

```hcl
variable "aws_region" {
  type        = string
  description = "AWS region for deployments"
  default     = "us-west-1"
}

variable "aws_identity_token" {
  type        = string
  description = "OIDC identity token"
  ephemeral   = true    # Does not persist to state file
  sensitive   = true    # Hidden in logs
}

variable "instance_count" {
  type        = number
  # nullable not supported - use default = null if needed
  default     = 1
}
```

### Required Providers Block

Works the same as traditional Terraform configurations:

```hcl
required_providers {
  aws = {
    source  = "hashicorp/aws"
    version = "~> 5.7.0"
  }
  random = {
    source  = "hashicorp/random"
    version = "~> 3.5.0"
  }
}
```

### Provider Block

Provider blocks differ from traditional Terraform:

1. Support `for_each` meta-argument
2. Define aliases in the block header (not as an argument)
3. Accept configuration through a `config` block

**Single Provider Configuration:**

```hcl
provider "aws" "this" {
  config {
    region = var.aws_region
    assume_role_with_web_identity {
      role_arn           = var.role_arn
      web_identity_token = var.aws_identity_token
    }
  }
}
```

**Multiple Provider Configurations with for_each:**

```hcl
provider "aws" "configurations" {
  for_each = var.regions
  
  config {
    region = each.value
    assume_role_with_web_identity {
      role_arn           = var.role_arn
      web_identity_token = var.aws_identity_token
    }
  }
}
```

### Component Block

Each Stack requires at least one component block. Add a component for each module to include in the Stack.

**Component Source Types:**
- Local file paths: `./modules/vpc`
- Public registry: `terraform-aws-modules/vpc/aws`
- Private registry: `app.terraform.io/my-org/vpc/aws`
- Git repositories: `git::https://github.com/org/repo.git//modules/vpc?ref=v1.0.0`

```hcl
component "vpc" {
  source = "./modules/vpc"

  inputs = {
    cidr_block  = var.vpc_cidr
    name_prefix = var.name_prefix
  }

  providers = {
    aws = provider.aws.this
  }
}

component "networking" {
  source  = "app.terraform.io/my-org/vpc/aws"
  version = "2.1.0"

  inputs = {
    cidr_block  = var.vpc_cidr
    environment = var.environment
  }

  providers = {
    aws = provider.aws.this
  }
}

component "compute" {
  source = "./modules/compute"

  inputs = {
    vpc_id          = component.vpc.vpc_id
    subnet_ids      = component.vpc.private_subnet_ids
    instance_type   = var.instance_type
  }

  providers = {
    aws = provider.aws.this
  }
}
```

**Component with for_each for Multi-Region:**

```hcl
component "s3" {
  for_each = var.regions
  
  source = "./modules/s3"
  
  inputs = {
    region = each.value
    tags   = var.common_tags
  }
  
  providers = {
    aws = provider.aws.configurations[each.value]
  }
}
```

**Key Points:**
- Reference component outputs using `component.<name>.<output>`
- All inputs are provided as a single `inputs` object
- Provider references are normal values: `provider.<type>.<alias>`
- Dependencies are automatically inferred from component references

### Component Meta-Arguments

Components support meta-arguments for advanced control:

**for_each** - Create multiple instances of a component:
```hcl
component "regional_bucket" {
  for_each = var.regions
  
  source = "./modules/s3"
  
  inputs = {
    region = each.value
    name   = "bucket-${each.key}"
  }
  
  providers = {
    aws = provider.aws.regional[each.value]
  }
}

# Reference outputs: component.regional_bucket["us-east-1"].bucket_id
```

**depends_on** - Explicit dependency (when implicit isn't detected):
```hcl
component "app" {
  source = "./modules/app"
  
  depends_on = [
    component.database
  ]
  
  inputs = {
    config = "app-config"
  }
  
  providers = {
    aws = provider.aws.this
  }
}
```

**lifecycle** - Control component replacement behavior:
```hcl
component "database" {
  source = "./modules/rds"
  
  lifecycle {
    prevent_destroy = true
  }
  
  inputs = {
    engine = "postgres"
  }
  
  providers = {
    aws = provider.aws.this
  }
}
```

### Output Block

Outputs require a `type` argument and do not support `preconditions`:

```hcl
output "vpc_id" {
  type        = string
  description = "VPC ID"
  value       = component.vpc.vpc_id
}

output "endpoint_urls" {
  type      = map(string)
  value     = {
    for region, comp in component.api : region => comp.endpoint_url
  }
  sensitive = false
}
```

### Locals Block

Works exactly as in traditional Terraform:

```hcl
locals {
  common_tags = {
    Environment = var.environment
    ManagedBy   = "Terraform Stacks"
    Project     = var.project_name
  }
  
  region_config = {
    for region in var.regions : region => {
      name_suffix = "${var.environment}-${region}"
    }
  }
}
```

### Removed Block

Use to safely remove components from a Stack. HCP Terraform requires the component's providers to remove it.

```hcl
removed {
  from   = component.old_component
  source = "./modules/old-module"
  
  providers = {
    aws = provider.aws.this
  }
}
```

## Deployment Configuration (.tfdeploy.hcl)

### Identity Token Block

Generate JWT tokens for OIDC authentication with cloud providers. Use GA audience values.

```hcl
identity_token "aws" {
  audience = ["aws.workload.identity"]  # GA audience for AWS
}

identity_token "azure" {
  audience = ["api://AzureADTokenExchange"]
}

identity_token "gcp" {
  audience = ["//iam.googleapis.com/projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID"]
}
```

**Authentication Pattern:**
1. Declare `identity_token` block in `deployments.tfdeploy.hcl`
2. Declare matching variable in `variables.tfcomponent.hcl` (e.g., `aws_identity_token`)
3. Pass token in deployment: `aws_identity_token = identity_token.aws.jwt`
4. Reference in provider config: `web_identity_token = var.aws_identity_token`

### Locals Block

Define local values for deployment configuration:

```hcl
locals {
  aws_regions = ["us-west-1", "us-east-1", "eu-west-1"]
  role_arn    = "arn:aws:iam::123456789012:role/hcp-terraform-stacks"
}
```

### Deployment Block

Define deployment instances. Each Stack requires at least one deployment (maximum 20 per Stack).

**Single Environment Deployment:**

```hcl
deployment "production" {
  inputs = {
    regions            = ["us-west-1"]
    role_arn           = local.role_arn
    aws_identity_token = identity_token.aws.jwt
  }
}
```

**Multiple Environment Deployments:**

```hcl
deployment "development" {
  inputs = {
    regions            = ["us-east-1"]
    role_arn           = local.role_arn
    aws_identity_token = identity_token.aws.jwt
  }
}

deployment "staging" {
  inputs = {
    regions            = ["us-east-1", "us-west-2"]
    role_arn           = local.role_arn
    aws_identity_token = identity_token.aws.jwt
  }
}

deployment "production" {
  inputs = {
    regions            = ["us-west-1", "us-east-1", "eu-west-1"]
    role_arn           = local.role_arn
    aws_identity_token = identity_token.aws.jwt
  }
}
```

**Destroying a Deployment:**

To safely remove a deployment:

```hcl
deployment "old_environment" {
  inputs = {
    regions            = ["us-west-1"]
    role_arn           = local.role_arn
    aws_identity_token = identity_token.aws.jwt
  }
  destroy = true  # Mark for destruction
}
```

After applying the plan and the deployment is destroyed, remove the deployment block from your configuration.

### Deployment Group Block

Group deployments together to configure shared settings (Premium feature). **Best Practice**: Always create deployment groups for all deployments, even single deployments, to enable future auto-approval rules and maintain consistent configuration patterns.

**IMPORTANT**: deployment_group blocks do NOT have a `deployments` argument. Instead, deployments reference which group they belong to.

```hcl
# CORRECT: deployment_group with auto_approve_checks
deployment_group "development" {
  auto_approve_checks = [
    deployment_auto_approve.dev_rapid_iteration
  ]
}

deployment_group "production" {
  # No auto_approve_checks = manual approval required
}
```

### Deployment Auto-Approve Block

Define rules that automatically approve deployment plans based on specific conditions (Premium feature).

**IMPORTANT PATTERN:**
1. Define `deployment_auto_approve` blocks FIRST (with check conditions)
2. Define `deployment_group` blocks (referencing auto_approve_checks)
3. Define `deployment` blocks (referencing deployment_group)

```hcl
# 1. Define auto-approval rules FIRST
deployment_auto_approve "dev_rapid_iteration" {
  check {
    condition = context.plan.applyable
    reason    = "Plan must be applyable"
  }
  
  check {
    condition = context.plan.changes.total <= 50
    reason    = "Development allows up to 50 changes"
  }
}

# 2. Define deployment groups with auto_approve_checks
deployment_group "development" {
  auto_approve_checks = [
    deployment_auto_approve.dev_rapid_iteration
  ]
}

# 3. Deployments reference the group
deployment "dev" {
  inputs = {
    regions = ["us-east-1"]
  }
  
  deployment_group = deployment_group.development
}
```
```

**Available Context Variables:**
- `context.plan.applyable` - Plan succeeded without errors
- `context.plan.changes.add` - Number of resources to add
- `context.plan.changes.change` - Number of resources to change
- `context.plan.changes.remove` - Number of resources to remove
- `context.plan.changes.total` - Total number of changes (add + change + remove)
- `context.plan.timestamp.hour` - Hour of the plan (0-23, UTC)
- `context.plan.timestamp.day` - Day of week (0-6, Sunday=0)
- `context.plan.timestamp.unix` - Unix timestamp

**NOT Available:**
- `context.plan.deployment_state()` - Does NOT exist
- References to other deployments
- Cross-deployment conditions

**Note:** `orchestrate` blocks are deprecated. Use `deployment_group` and `deployment_auto_approve` instead.

### Store Block (Variable Sets)

Access HCP Terraform Variable Sets to retrieve centralized configuration values (Premium feature).

**IMPORTANT**: Values from store blocks are ephemeral and require matching variables with `ephemeral = true`.

```hcl
# In deployments.tfdeploy.hcl
store "varset" "stacks_config" {
  name     = "my-variable-set-name"
  category = "terraform"
}

deployment "production" {
  inputs = {
    role_arn = store.varset.stacks_config.role_arn
  }
}

# In variables.tfcomponent.hcl - MUST be ephemeral
variable "role_arn" {
  type        = string
  ephemeral   = true  # Required for store values
  sensitive   = true  # Optional but recommended
}
```

**Pattern:**
1. Declare `store` block in `deployments.tfdeploy.hcl`
2. Declare matching variable with `ephemeral = true` in `variables.tfcomponent.hcl`
3. Pass store value in deployment: `role_arn = store.varset.stacks_config.role_arn`

### Publish Output Block

Export outputs from a Stack for use in other Stacks (linked Stacks). Requires Stack outputs to be declared first in `outputs.tfcomponent.hcl`.

**IMPORTANT**: publish_output blocks do NOT have a `type` argument. The type comes from the Stack output.

```hcl
# First, declare Stack outputs in outputs.tfcomponent.hcl
output "vpc_id" {
  type  = string
  value = component.vpc.vpc_id
}

output "subnet_ids" {
  type  = list(string)
  value = component.vpc.private_subnet_ids
}

# Then, publish deployment outputs in deployments.tfdeploy.hcl
publish_output "network_vpc_id" {
  value = deployment.network.vpc_id
}

publish_output "network_subnets" {
  value = deployment.network.subnet_ids
}
```

**Flow**: Component output → Stack output → Deployment output → Published output

### Upstream Input Block

Reference published outputs from another Stack:

```hcl
upstream_input "network_stack" {
  type   = "stack"
  source = "app.terraform.io/my-org/my-project/networking-stack"
}

deployment "application" {
  inputs = {
    vpc_id     = upstream_input.network_stack.vpc_id_network
    subnet_ids = upstream_input.network_stack.subnet_ids
  }
}
```

## Terraform Stacks CLI

**Minimum Version**: Terraform v1.13.5 (GA release)

### Initialize and Validate

Generate provider lock file:

```bash
terraform stacks providers-lock
```

Validate Stack configuration:

```bash
terraform stacks validate
```

### Plan and Apply

Plan a specific deployment:

```bash
terraform stacks plan --deployment=production
```

Apply a deployment:

```bash
terraform stacks apply --deployment=production
```

## Common Patterns

### Multi-Region Deployment

```hcl
# variables.tfcomponent.hcl
variable "regions" {
  type = set(string)
}

variable "aws_identity_token" {
  type      = string
  ephemeral = true
  sensitive = true
}

variable "role_arn" {
  type = string
}

# providers.tfcomponent.hcl
provider "aws" "regional" {
  for_each = var.regions
  
  config {
    region = each.value
    assume_role_with_web_identity {
      role_arn           = var.role_arn
      web_identity_token = var.aws_identity_token
    }
  }
}

# components.tfcomponent.hcl
component "regional_infra" {
  for_each = var.regions
  source   = "./modules/regional"
  
  inputs = {
    region = each.value
  }
  
  providers = {
    aws = provider.aws.regional[each.value]
  }
}
```

### Component Dependencies

Dependencies are automatically inferred when one component references another's output:

```hcl
component "database" {
  source = "./modules/rds"
  
  inputs = {
    subnet_ids = component.vpc.private_subnet_ids  # Creates dependency
  }
  
  providers = {
    aws = provider.aws.this
  }
}
```

## Best Practices

1. **Component Granularity**: Create components for logical infrastructure units that share a lifecycle
2. **Module Compatibility**: Modules used with Stacks cannot include provider blocks (configure providers in Stack configuration)
3. **State Isolation**: Each deployment has its own isolated state
4. **Input Variables**: Use variables for values that differ across deployments; use locals for shared values
5. **Provider Lock Files**: Always generate and commit `.terraform.lock.hcl` to version control
6. **Naming Conventions**: Use descriptive names for components and deployments
7. **Deployment Groups**: Always organize deployments into deployment groups, even if you only have one deployment
8. **Testing**: Test Stack configurations in dev/staging deployments before production
9. **Version Pinning**: Use `.terraform-version` file to ensure consistent Terraform version (1.13.5+)
10. **Variable Validation**: Implement input validation in component modules, not Stack variables (validation blocks not supported)
11. **OIDC Authentication**: Always use GA audience values (`aws.workload.identity` for AWS, not beta values)
12. **Deployment Inputs**: Only pass variables that components actually use - remove unused inputs to avoid errors

## Troubleshooting

### Common Errors and Solutions

**Error: "nullable is not expected"**
- **Cause**: `nullable` attribute not supported in Terraform Stacks v1.13.5+
- **Solution**: Remove `nullable` attribute; use `default = null` if needed

**Error: "validation block not expected"**
- **Cause**: Validation blocks not supported in Stack variables
- **Solution**: Implement validation in component modules instead

**Error: "deployments argument not expected in deployment_group"**
- **Cause**: Incorrect relationship - deployments don't go inside deployment_group
- **Solution**: Add `deployment_group = deployment_group.name` to deployment blocks instead

**Error: "deployment_group argument not expected in deployment_auto_approve"**
- **Cause**: Auto-approval rules don't reference deployment groups directly
- **Solution**: deployment_group blocks reference auto_approve_checks, not the other way around

**Error: "type argument not expected in publish_output"**
- **Cause**: publish_output gets type from Stack output, not defined inline
- **Solution**: Remove `type` argument; ensure Stack output in outputs.tfcomponent.hcl declares the type

**Error: Variable from store block causes errors**
- **Cause**: Variables receiving store values must be declared as ephemeral
- **Solution**: Add `ephemeral = true` to variable declaration in variables.tfcomponent.hcl

### Circular Dependencies

**Issue**: Component A references Component B, and Component B references Component A
**Solution**: Refactor to break the circular reference or use intermediate components

### Deployment Limit

HCP Terraform supports maximum 20 deployments per Stack. For more instances, use multiple Stacks or `for_each` within components.

## References

For detailed block specifications and advanced features, see:
- `references/component-blocks.md` - Complete component block reference
- `references/deployment-blocks.md` - Complete deployment block reference
- `references/examples.md` - Complete working examples for common scenarios

## Key Takeaways

1. **Deployment Relationship Pattern**: 
   - `deployment_auto_approve` blocks define rules (no references)
   - `deployment_group` blocks have `auto_approve_checks = [...]`
   - `deployment` blocks have `deployment_group = deployment_group.name`

2. **Variable Patterns**:
   - No `validation` blocks in Stack variables
   - No `nullable` attribute in v1.13.5+
   - Store values require `ephemeral = true`
   - Identity tokens require `ephemeral = true`

3. **Output Patterns**:
   - Stack outputs require `type` declaration
   - `publish_output` does NOT have `type` (inherits from Stack output)
   - Flow: Component → Stack output → Deployment output → Published output

4. **OIDC Authentication**:
   - Use GA audiences: `aws.workload.identity` for AWS
   - Beta audiences like `terraform-stacks-private-preview` are deprecated
   - Pattern: identity_token block → variable (ephemeral) → deployment input → provider config

5. **Provider Innovation**:
   - `for_each` on providers only works in Stacks (not traditional Terraform)
   - Providers use `config` blocks (not direct arguments)
   - Aliases defined in block header: `provider "aws" "alias_name" {}`